## **Домашнее задание №7:**
**Механизм блокировок**
1.   Создад кластер, установил на него  PostgreSQL 15 с дефолтными настройками:
im1

2.   Для того, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд, нужна включить настройку log_lock_waits и у настройки deadlock_timeout выставить значение 200.
Выставление настроек делал через alter system:
im2
3.  Создал базу данных locks, создал таблицу account и заполнил ее данными:
    ```
    postgres=# \c locks
    SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, compression: off)
    You are now connected to database "locks" as user "postgres".
    locks=# \dt
            List of relations
    Schema |   Name   | Type  |  Owner
    --------+----------+-------+----------
    public | accounts | table | postgres
    (1 row)

    locks=# select * from accounts;
    acc_no | amount
    --------+---------
        2 | 2000.00
        3 | 3000.00
        1 | 1400.00
    (3 rows)

    locks=#
    ```
4.  Смоделируем ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах.
5. Первый сеанс, открываем транзыкцию и выполняем update, видим:   
    3im
6.  Второй сеанс, выполняем тоже update
    
    4im

7. Третий сеаенс и видим, что в втором и в третьем update не выполняется
:

8.  Посмотрим лог, наблюдаем блокировки во второй и в третьих сессиях:
6
9.  В первой сессии мы можем наблюдать, что RowExclusiveLock установлен на отношение accounts
7
10. Во второй сессии мы наблюдаем, что у нас появилась блокировка transactionid в режиме ShareLock и tuple для выполняемого обновления.
8
11. В третьей же мы видим блокировку tuple в режиме ExclusiveLock
9
12. Завершим первую сессию. Все блокировки ушли!
10
13. Воспроизведите взаимоблокировку трех транзакций.
    Воспроизвести удалось:
    11im
14. Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
 Могут! Если обновление будет происходить в обратных последовательностях

    

